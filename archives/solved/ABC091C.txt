void solve();

int main() {
	solve();
	return 0;
}

//////////////////////////////////////////////////
//////////////////////////////////////////////////
#include <iostream>
#include <vector>
#include <queue>
#include <limits.h>
#include <algorithm>
#include <deque>

using namespace std;

class flow {
private:
	class edge {
	public:
		int to;
		long long cap;
		int rev;  //‹t•Ó‚ªG[to]‚Ì‚Ç‚±‚É‚¢‚é‚©
		edge(int t, int c, int r) :to(t), cap(c), rev(r) {}
		edge() :to(0), cap(0), rev(0) {}
	};
	int V;
	vector<vector<edge>>* G;
	vector<int>* lev;   //n“_s‚©‚ç‚Ì‹——£
	vector<int>* iter;   //‚Ç‚Ì•Ó‚Ü‚ÅŒ©‚½‚©
	//•—Dæ‚ÅÅ’Z‹——£
	void bfs(int s) {
		for (int n = 0; n < V; n++)lev->at(n) = -1;
		queue<int> que;
		lev->at(s) = 0;
		que.push(s);
		while (!que.empty()) {
			int v = que.front(); que.pop();
			for (int i = 0; i < G->at(v).size(); i++) {
				edge& e = G->at(v)[i];
				if (e.cap > 0 && lev->at(e.to) < 0) {
					lev->at(e.to) = lev->at(v) + 1;
					que.push(e.to);
				}
			}
		}
	}
	//‘‰ÁƒpƒX‚ÌŒŸõ&—¬‚·
	int dfs(int v, int t, long long f) {
		if (v == t)return f;
		for (int& i = iter->at(v); i < G->at(v).size(); i++) {
			edge& e = G->at(v)[i];
			if (e.cap > 0 && lev->at(v) < lev->at(e.to)) {
				int d = dfs(e.to, t, min(f, e.cap));
				if (d > 0) {
					e.cap -= d;
					G->at(e.to)[e.rev].cap += d;
					return d;
				}
			}
		}
		return 0;
	}
public:
	flow(int v) :V(v) {
		G = new vector<vector<edge>>;
		G->resize(V);
		lev = new vector<int>;
		iter = new vector<int>;
		lev->resize(V);
		iter->resize(V);
	}
	~flow() {
		delete G;
		delete lev;
		delete iter;
	}
	//•Ó’Ç‰Á
	void addEdge(int from, int to, int cap) {
		G->at(from).push_back(edge(to, cap, G->at(to).size()));
		G->at(to).push_back(edge(from, 0, G->at(from).size() - 1));
	}
	//Å‘å—¬–â‘è‚ğ‰ğ‚­(Dinic)
	//O(EV^2)
	static int maxFlow(flow& F, int s, int t) {
		int flowint = 0;
		for (;;) {
			F.bfs(s);
			if (F.lev->at(t) < 0)return flowint;
			int a = 0;
			for (int v = 0; v < F.V; v++)F.iter->at(v) = 0;
			int f;
			while ((f = F.dfs(s, t, LLONG_MAX)) > 0) {
				flowint += f;
			}
		}
	}
};


int N;
typedef pair<int, int> pii;
vector<pii> red, blue;
void solve() {
	cin >> N;
	flow F(2 * N + 2);
	for (int i = 1; i <= N; i++) {
		F.addEdge(0, i, 1);
		F.addEdge(i + N, 2 * N + 1, 1);
	}
	red.resize(N); blue.resize(N);
	for (int n = 1; n <= N; n++) {
		cin >> red[n - 1].first >> red[n - 1].second;
	}
	for (int n = 1; n <= N; n++) {
		cin >> blue[n - 1].first >> blue[n - 1].second;
	}
	for (int r = 0; r < N; r++) {
		for (int b = 0; b < N; b++) {
			if (red[r].first < blue[b].first && red[r].second < blue[b].second) {
				F.addEdge(r + 1, N + b + 1, 1);
			}
		}
	}
	cout << flow::maxFlow(F, 0, 2 * N + 1) << endl;
	return;
}
void solve();

int main() {
	solve();
	return 0;
}

//////////////////////////////////////////////////
//////////////////////////////////////////////////
#define _USE_MATH_DEFINES
#include <algorithm>
#include <vector>
#include <set>
#include <queue>
#include <functional>
#include <map>
#include <string>
#include <boost/multiprecision/cpp_int.hpp>
#include <limits.h>
#include <iomanip>
#include <stack>
#include <complex>

using namespace std;
using namespace boost::multiprecision;

using Complex = complex<double>;

//DFT(—£UFouriet•ÏŠ·)
//A:•ÏŠ·‚µ‚½‚¢‘½€®(A[i]=iŸ‚ÌŒW”)’¼•ÏX!!!!!,N:1‚Ì‰½æª?(2‚Ì—İæ”),sgn:‹t•ÏŠ·‚Ì-1‚É
void dft(vector<Complex>* A, int N, int sgn = 1) {
	if (N == 1) return;

	vector<Complex>* F = new vector<Complex>(N / 2);
	vector<Complex>* G = new vector<Complex>(N / 2);
	for (int i = 0; i < N / 2; i++) {
		F->at(i) = A->at(2 * i + 0);
		G->at(i) = A->at(2 * i + 1);
	}

	dft(F, N / 2, sgn);
	dft(G, N / 2, sgn);

	Complex zeta(cos(2.0 * M_PI / N), sin(2.0 * M_PI / N) * sgn);
	Complex pow_zeta = 1;

	for (int i = 0; i < N; i++) {
		A->at(i) = F->at(i % (N / 2)) + pow_zeta * G->at(i % (N / 2));
		pow_zeta *= zeta;
	}
	delete F, G;
	return;
}

//inverse DFT(—£UFouriet‹t•ÏŠ·)
//A:•ÏŠ·‚µ‚½‚¢‘½€®,N:—v‘f”(2‚Ì—İæ”)
void inv_dft(vector<Complex>* A, int N) {
	dft(A, N, -1);
	for (int i = 0; i < N; i++) {
		A->at(i) /= N;
	}
	return;
}

//‘½€®‚Ìô‚İ‚İ(FFT,inverse FFT‚ğg‚¤)
//A,B:‘½€®(‘‚«•Ï‚í‚è‚Ü‚·...),C:Œ‹‰Ê•Û‘¶—p
void multiply(vector<Complex>& A, vector<Complex>& B,vector<Complex>& C) {
	int sz = A.size() + B.size() + 1;
	int n = 1;
	while (n < sz) n *= 2;
	
	A.resize(n), B.resize(n);
	dft(&A, n);
	dft(&B, n);

	C.resize(n);
	for (int i = 0; i < n; i++) {
		C[i] = A[i] * B[i];
	}
	inv_dft(&C, n);
	return;
}

int N;
vector<Complex> A, B,C;

void solve() {
	cin >> N;
	A.resize(N + 1);
	B.resize(N + 1);
	A[0] = 0;
	B[0] = 0;
	for (int n = 1; n <= N; n++) {
		int a, b;
		cin >> a >> b;
		A[n] = Complex(a, 0);
		B[n] = Complex(b, 0);
	}
	multiply(A, B, C);
	for (int k = 1; k <= 2 * N; k++) {
		cout << (int)(C[k].real()+0.5) << endl;
	}
	return;
}

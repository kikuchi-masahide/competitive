#include <iostream>
#include <vector>
#include <limits.h>
#include <algorithm>
#include <string>
#include <math.h>
#include <limits.h>
#include <queue>
#include <map>
#include <set>
#include <iomanip>
#include <bitset>
#include <cassert>
#include <random>
#include <functional>
#include <stack>
#include <iomanip>
#include <cassert>
//#include <boost/multiprecision/cpp_int.hpp>
using namespace std;
const long long MOD = 1e9+7;
typedef long long ll;
typedef long double ld;
typedef pair<ll, ll> pll;
typedef pair<ld, ll> pdl;
typedef pair<ld, ld> pdd;
//typedef boost::multiprecision::cpp_int bigint;

vector<pll> vecs = {
	pll(0,1),pll(1,1),pll(1,0),pll(1,-1),pll(0,-1),pll(-1,-1),pll(-1,0),pll(-1,1)
};
vector<vector<ll>> ans,board;   //1->• 0->”’ -1->–¢Œˆ’è
ll W, H;

int main() {
	cin >> H >> W;
	board.resize(W, vector<ll>(H, 0));
	ans.resize(W, vector<ll>(H, -1));
	for (ll y = 0; y < H; y++) {
		string S;
		cin >> S;
		for (ll x = 0; x < W; x++) {
			if (S[x] == '#')board[x][y] = 1;
			else board[x][y] = 0;
		}
	}
	for (ll x = 0; x < W; x++) {
		for (ll y = 0; y < H; y++) {
			if (board[x][y] == 0) {
				ans[x][y] = 0;
				for (ll v = 0; v < 8; v++) {
					ll xx = x + vecs[v].first;
					ll yy = y + vecs[v].second;
					if (xx < 0 || xx >= W || yy < 0 || yy >= H)continue;
					ans[xx][yy] = 0;
				}
			}
		}
	}
	for (ll x = 0; x < W; x++) {
		for (ll y = 0; y < H; y++) {
			if (ans[x][y] == -1)ans[x][y] = 1;
		}
	}
	//•œŒ³‚µ‚Ä‚Ý‚é
	bool flag = false;
	for (ll x = 0; x < W&&!flag; x++) {
		for (ll y = 0; y < H&&!flag; y++) {
			ll res = ans[x][y];
			for (ll v = 0; v < 8; v++) {
				ll xx = x + vecs[v].first;
				ll yy = y + vecs[v].second;
				if (xx < 0 || xx >= W || yy < 0 || yy >= H)continue;
				if (ans[xx][yy] == 1)res = 1;
			}
			if (res != board[x][y])flag = true;
		}
	}
	if (flag)cout << "impossible" << endl;
	else {
		cout << "possible" << endl;
		for (ll y = 0; y < H; y++) {
			for (ll x = 0; x < W; x++) {
				if (ans[x][y] == 1)cout << "#";
				else cout << ".";
			}
			cout << endl;
		}
	}
	return 0;
}

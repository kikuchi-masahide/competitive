#include <iostream>
#include <vector>
#include <limits.h>
#include <algorithm>
#include <string>
#include <math.h>
#include <limits.h>
#include <queue>
#include <map>
#include <set>
#include <iomanip>
#include <bitset>
#include <cassert>
#include <random>
#include <functional>
#include <stack>
#include <iomanip>
#include <cassert>
using namespace std;
long long MOD = 1e9 + 7;

template< typename flow_t, typename cost_t >
struct PrimalDual {
	const cost_t INF;

	struct edge {
		int to;
		flow_t cap;
		cost_t cost;
		int rev;
		bool isrev;
	};
	vector< vector< edge > > graph;
	vector< cost_t > potential, min_cost;
	vector< int > prevv, preve;

	PrimalDual(int V) : graph(V), INF(numeric_limits< cost_t >::max()) {}

	void add_edge(int from, int to, flow_t cap, cost_t cost) {
		edge a = { to, cap, cost, (int)graph[to].size(), false };
		graph[from].emplace_back(a);
		a = { from, 0, -cost, (int)graph[from].size() - 1, true };
		graph[to].emplace_back(a);
	}

	cost_t min_cost_flow(int s, int t, flow_t f) {
		int V = (int)graph.size();
		cost_t ret = 0;
		using Pi = pair< cost_t, int >;
		priority_queue< Pi, vector< Pi >, greater< Pi > > que;
		potential.assign(V, 0);
		preve.assign(V, -1);
		prevv.assign(V, -1);

		while (f > 0) {
			min_cost.assign(V, INF);
			que.emplace(0, s);
			min_cost[s] = 0;
			while (!que.empty()) {
				Pi p = que.top();
				que.pop();
				if (min_cost[p.second] < p.first) continue;
				for (int i = 0; i < graph[p.second].size(); i++) {
					edge& e = graph[p.second][i];
					cost_t nextCost = min_cost[p.second] + e.cost + potential[p.second] - potential[e.to];
					if (e.cap > 0 && min_cost[e.to] > nextCost) {
						min_cost[e.to] = nextCost;
						prevv[e.to] = p.second, preve[e.to] = i;
						que.emplace(min_cost[e.to], e.to);
					}
				}
			}
			if (min_cost[t] == INF) return -1;
			for (int v = 0; v < V; v++) potential[v] += min_cost[v];
			flow_t addflow = f;
			for (int v = t; v != s; v = prevv[v]) {
				addflow = min(addflow, graph[prevv[v]][preve[v]].cap);
			}
			f -= addflow;
			ret += addflow * potential[t];
			for (int v = t; v != s; v = prevv[v]) {
				edge& e = graph[prevv[v]][preve[v]];
				e.cap -= addflow;
				graph[v][e.rev].cap += addflow;
			}
		}
		return ret;
	}

	void output() {
		for (int i = 0; i < graph.size(); i++) {
			for (auto& e : graph[i]) {
				if (e.isrev) continue;
				auto& rev_e = graph[e.to][e.rev];
				cout << i << "->" << e.to << " (flow: " << rev_e.cap << "/" << rev_e.cap + e.cap << ")" << endl;
			}
		}
	}
};

int N;
vector<vector<int>> W, E;
vector<vector<int>> M;   //ó‹µ 1->o

int main() {
	cin >> N;
	W.resize(N, vector<int>(N, 0));
	E.resize(N, vector<int>(N, 0));
	for (int x = 0; x < N; x++) {
		for (int y = 0; y < N; y++)cin >> W[x][y];
	}
	for (int x = 0; x < N; x++) {
		for (int y = 0; y < N; y++)cin >> E[x][y];
	}
	M.resize(N, vector<int>(N, 0));
	for (int x = 0; x < N; x++) {
		string S;
		cin >> S;
		for (int y = 0; y < N; y++) {
			if (S[y] == 'o')M[x][y] = 1;
		}
	}
	PrimalDual<long long,long long> flow(2 * N + 2);
	for (int x = 0; x < N; x++) {
		for (int y = 0; y < N; y++) {
			long long temp = 0;
			if (M[x][y] == 0)temp += 2 * W[x][y];
			for (int x0 = 0; x0 < N; x0++) {
				if (x0 == x)continue;
				if (M[x0][y] == 1)temp += E[x0][y];
			}
			for (int y0 = 0; y0 < N; y0++) {
				if (y0 == y)continue;
				if (M[x][y0] == 1)temp += E[x][y0];
			}
			flow.add_edge(x + 1, N + y + 1, 1, temp);
		}
	}
	for (int x = 1; x <= N; x++)flow.add_edge(0, x, 1, 0);
	for (int y = 1; y <= N; y++)flow.add_edge(y + N, 2 * N + 1, 1, 0);
	cout << flow.min_cost_flow(0, 2 * N + 1, N)/2 << endl;
	int counter = 0;
	vector<string> output;
	for (int x = 0; x < N; x++) {
		for (auto e : flow.graph[1 + x]) {
			if (e.isrev) continue;
			auto& rev_e = flow.graph[e.to][e.rev];
			if (rev_e.cap == 0)continue;
			int y = e.to;
			if (M[x][y - 1 - N] == 0) {
				string s = to_string(x+1)+string(" ")+to_string(y - N)+string(" write");
				counter++;
				output.push_back(s);
			}
			for (int y0 = 0; y0 < N; y0++) {
				if (y0 == y-1-N)continue;
				if (M[x][y0] == 1) {
					string s = to_string(x + 1) + string(" ") + to_string(y0+1) + string(" erase");
					counter++;
					output.push_back(s);
				}
			}
		}
	}
	cout << counter << endl;
	for (string s : output) {
		cout << s << endl;
	}
	return 0;
}
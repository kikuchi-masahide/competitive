#include <iostream>
#include <vector>
#include <limits.h>
#include <algorithm>
#include <string>
#include <math.h>
#include <limits.h>
#include <queue>
#include <map>
#include <set>
#include <iomanip>
#include <bitset>
#include <cassert>
#include <random>
#include <functional>
#include <stack>
#include <iomanip>
#include <cassert>
//#include <boost/multiprecision/cpp_int.hpp>
#include <complex>
#include <cstdio>

using namespace std;
//std::ios::sync_with_stdio(false);
//std::cin.tie(0);
const long long MOD = 1e9 + 7;
typedef long long ll;
typedef long double ld;
typedef pair<ll, ll> pll;
typedef pair<ld, ll> pdl;
typedef pair<ld, ld> pdd;
typedef vector<ll> VLL;
typedef vector<VLL> VVLL;
//typedef boost::multiprecision::cpp_int bigint;

//‹óvector‚ğ—v‘f”N‚ÌsegTree‚Æ‚µ‚Äz‚Å‰Šú‰»
template<class T>
void segTree_init(vector<T>& vec, int N, T z) {
	int RN = 1;
	while (RN < N)RN *= 2;
	vec.resize(2 * RN, z);
}

void segTree_set(vector<pll>& vec, ll s, ll t, ll time,ll x, ll k = 1, ll l = 0, ll r = -1) {
	if (r == -1)r = vec.size() / 2-1;
	if (t < l || s > r)return;
	if (s <= l && r <= t)vec[k] = pll(x, time);
	else {
		segTree_set(vec, s, t, time, x, 2 * k, l, (l + r) / 2);
		segTree_set(vec, s, t, time, x, 2 * k + 1, (l+r)/2+1, r);
	}
	return;
}

//vec‚ªsegTree‚Ì‚ÌAn”Ô–Ú‚Ì—v‘f
ll segTree_at(vector<pll>& vec, int n) {
	int RN = (vec.size()) / 2;
	ll k = RN + n;
	ll t = vec[k].second, x = vec[k].first;
	while (k >= 1) {
		k /= 2;
		if (vec[k].second > t) {
			t = vec[k].second;
			x = vec[k].first;
		}
	}
	return x;
}

vector <pll> seg;

int main() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(0);
	ll N,Q;
	cin >> N >> Q;
	segTree_init(seg, N, pll(((ll)1 << 31) - 1,0));
	for (ll q = 0; q < Q; q++) {
		ll com;
		cin >> com;
		if (com == 0) {
			ll s, t, x;
			cin >> s >> t >> x;
			segTree_set(seg, s, t, q+1, x);
		}
		else if (com == 1) {
			ll i;
			cin >> i;
			cout << segTree_at(seg, i) << "\n";
		}
	}
	return 0;
}
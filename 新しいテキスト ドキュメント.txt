void solve();

int main() {
	solve();
	return 0;
}

//////////////////////////////////////////////////
//////////////////////////////////////////////////
#include <iostream>
#include <algorithm>
#include <vector>
#include <set>
#include <queue>
#include <functional>
#include <map>
#include <string>
#include <boost/multiprecision/cpp_int.hpp>
#include <limits.h>
#include <iomanip>
#include <stack>

using namespace std;
using namespace boost::multiprecision;

int N, K, L;
vector<int> A;
vector<int> tempv;
vector<int> res;

void solve() {
	cin >> N >> K >> L;
	A.resize(N);
	for (int n = 0; n < N; n++)cin >> A[n];
	int n = 1;
	while (n*(n+1)/2 < L)n++;
	//[0,N-n+1),[1,N-n+2),...‚ÌK”Ô–Ú‚ÌÅ¬’l‚ð‹‚ß‚½‚¢
	for (int i = 0; i < N - n + 1; i++)tempv.push_back(A[i]);
	sort(tempv.begin(), tempv.end());
	res.push_back(tempv[K - 1]);
	for (int i = 1; i < n; i++) {
		//a_i-1‚ÌêŠ‚ð’T‚·
		int s = 0, e = N - n + 1;
		while (e - s >= 2) {
			int m = (e + s) / 2;
			if (tempv[m] <= A[i-1])s = m;
			else e = m;
		}
		tempv.erase(tempv.begin() + s);
		//a_N-n+i‚ÌêŠ‚ð’T‚·
		s = -1, e = N - n;
		while (e - s >= 2) {
			int m = (e + s) / 2;
			if (tempv[m] <= A[N - n + i])s = m;
			else e = m;
		}
		tempv.insert(tempv.begin() + e, A[N - n + i]);
		res.push_back(tempv[K - 1]);
	}
	sort(res.begin(), res.end());
	cout << res[L-(n-1)*n/2-1] << endl;
	return;
}